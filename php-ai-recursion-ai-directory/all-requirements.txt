//----- File: factory/ViewModelFactory.kt -----

package com.rzrasel.wordquiz.factory

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.rzrasel.wordquiz.feature.flatpractice.di.FlatPracticeModule
import com.rzrasel.wordquiz.feature.flatpractice.presentation.viewmodel.FlatPracticeViewModel

class ViewModelFactory(
    private val context: Context,
    private val userAuthToken: String = ""
) : ViewModelProvider.Factory {
    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(FlatPracticeViewModel::class.java)) {
            return FlatPracticeModule.provideViewModel(context, userAuthToken) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

/*
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import com.rzrasel.rztutorial.repository.AuthRepository
import com.rzrasel.rztutorial.repository.BaseRepository
import com.rzrasel.rztutorial.repository.RegistrationRepository
import com.rzrasel.rztutorial.repository.UserRepository
import com.rzrasel.rztutorial.viewmodel.AuthViewModel
import com.rzrasel.rztutorial.viewmodel.DashboardViewModel
import com.rzrasel.rztutorial.viewmodel.RegistrationViewModel
import java.lang.IllegalArgumentException

class ViewModelFactory(private val repository: BaseRepository): ViewModelProvider.NewInstanceFactory() {
    //override fun <T : ViewModel?> create(modelClass: Class<T>): T {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        return when {
            modelClass.isAssignableFrom(AuthViewModel::class.java) -> AuthViewModel(repository as AuthRepository) as T
            modelClass.isAssignableFrom(RegistrationViewModel::class.java) -> RegistrationViewModel(repository as RegistrationRepository) as T
            modelClass.isAssignableFrom(DashboardViewModel::class.java) -> DashboardViewModel(repository as UserRepository) as T
            else -> throw IllegalArgumentException("ViewModelClass not found")
        }
    }
}*/


//----- File: flatpractice/api/FlatPracticeApiService.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.api

import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeDto
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeRequest
import retrofit2.Response
import retrofit2.http.Body
import retrofit2.http.POST

interface FlatPracticeApiService {
    @POST("get-questions/")
    suspend fun getFlatPractice(
        @Body flatPracticeRequest: FlatPracticeRequest
    ): Response<FlatPracticeDto>

    @POST("get-questions/")
    suspend fun getFlatPracticeNext(
        @Body flatPracticeRequest: FlatPracticeRequest
    ): Response<FlatPracticeDto>

    @POST("submit-answer/")
    suspend fun getFlatPracticeSubmitAnswer(
        @Body flatPracticeRequest: FlatPracticeRequest
    ): Response<FlatPracticeDto>
}

//----- File: flatpractice/data/datasource/FlatPracticeRemoteDataSource.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.data.datasource

import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeDto
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeRequest
import com.rzrasel.wordquiz.networkstate.NetworkState

interface FlatPracticeRemoteDataSource {
    suspend fun getFlatPractice(flatPracticeRequest: FlatPracticeRequest): NetworkState<FlatPracticeDto>
    suspend fun getFlatPracticeNext(flatPracticeRequest: FlatPracticeRequest): NetworkState<FlatPracticeDto>
}

//----- File: flatpractice/data/datasource/FlatPracticeRemoteDataSourceImpl.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.data.datasource

import com.rzrasel.wordquiz.feature.flatpractice.api.FlatPracticeApiService
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeDto
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeRequest
import com.rzrasel.wordquiz.networkstate.NetworkState
import retrofit2.HttpException
import java.io.IOException
import java.net.SocketTimeoutException
import java.net.UnknownHostException

class FlatPracticeRemoteDataSourceImpl(
    private val apiService: FlatPracticeApiService
) : FlatPracticeRemoteDataSource {

    override suspend fun getFlatPractice(flatPracticeRequest: FlatPracticeRequest): NetworkState<FlatPracticeDto> {
        return handleApiCall { apiService.getFlatPractice(flatPracticeRequest) }
    }

    override suspend fun getFlatPracticeNext(flatPracticeRequest: FlatPracticeRequest): NetworkState<FlatPracticeDto> {
        return handleApiCall { apiService.getFlatPracticeNext(flatPracticeRequest) }
    }

    private suspend fun handleApiCall(
        apiCall: suspend () -> retrofit2.Response<FlatPracticeDto>
    ): NetworkState<FlatPracticeDto> {
        return try {
            val response = apiCall()
            if (response.isSuccessful) {
                NetworkState.Success(response.body())
            } else {
                NetworkState.Error("HTTP error: ${response.code()} - ${response.message()}")
            }
        } catch (e: SocketTimeoutException) {
            NetworkState.Error("Request timeout. Please check your connection.")
        } catch (e: UnknownHostException) {
            NetworkState.Error("No internet connection.")
        } catch (e: IOException) {
            NetworkState.Error("Network error: ${e.message ?: "Please check your connection"}")
        } catch (e: HttpException) {
            NetworkState.Error("HTTP error: ${e.message ?: "Unknown error"}")
        } catch (e: Exception) {
            NetworkState.Error("Unexpected error: ${e.message ?: "Something went wrong"}")
        }
    }
}


//----- File: flatpractice/data/mapper/FlatPracticeModelMapper.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.data.mapper

import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeAnswerItemModel
import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeDataModel
import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeModel
import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeQuestionItemModel
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeAnswerItemDto
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeDataDto
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeDto
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeQuestionItemDto

//Mapper (DTO â†’ Model) (DTO To Model)

fun FlatPracticeDto.toModel(): FlatPracticeModel {
    return FlatPracticeModel(
        type = type,
        message = message,
        data = data?.toModel()
    )
}

fun FlatPracticeDataDto.toModel(): FlatPracticeDataModel {
    return FlatPracticeDataModel(
        nextQuestionIndex = nextQuestionIndex,
        isLastQuestion = isLastQuestion,
        questionSet = ArrayList(questionSet?.map { it.toModel() } ?: emptyList())
    )
}

fun FlatPracticeQuestionItemDto.toModel(): FlatPracticeQuestionItemModel {
    return FlatPracticeQuestionItemModel(
        questionId = questionId,
        question = question,
        answerSet = answerSet.map { it.toModel() }
    )
}

fun FlatPracticeAnswerItemDto.toModel(): FlatPracticeAnswerItemModel {
    return FlatPracticeAnswerItemModel(
        answerId = answerId,
        answer = answer,
        isTure = isTure
    )
}

//----- File: flatpractice/data/remote/FlatPracticeDto.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.data.remote

import com.google.gson.annotations.SerializedName

data class FlatPracticeDto(
    @SerializedName("type")
    val type: String = "error",
    @SerializedName("message")
    val message: String?,
    @SerializedName("data")
    var data: FlatPracticeDataDto? = FlatPracticeDataDto(),
)

data class FlatPracticeDataDto(
    @SerializedName("next_question_index")
    var nextQuestionIndex: Int = 0,
    @SerializedName("is_last_question")
    var isLastQuestion: Boolean? = null,
    @SerializedName("question")
    var questionSet: ArrayList<FlatPracticeQuestionItemDto>? = arrayListOf(),
)

data class FlatPracticeQuestionItemDto(
    @SerializedName("question_id")
    val questionId: String? = null,
    @SerializedName("question")
    val question: String? = null,
    @SerializedName("answer_set")
    val answerSet: List<FlatPracticeAnswerItemDto> = listOf(),
)

data class FlatPracticeAnswerItemDto(
    @SerializedName("answer_id")
    val answerId: String? = null,
    @SerializedName("answer")
    val answer: String? = null,
    @SerializedName("is_true")
    val isTure: Boolean = false,
)

//----- File: flatpractice/data/remote/FlatPracticeRequest.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.data.remote

import com.google.gson.annotations.SerializedName

data class FlatPracticeRequest(
    @SerializedName("user_auth_token")
    var userAuthToken: String? = "",
    @SerializedName("is_login")
    var isLogin: Boolean = false,
    @SerializedName("category_id")
    val categoryId: String,
    @SerializedName("item_id")
    val itemId: String,
    @SerializedName("current_question_index")
    var currentQuestionIndex: Int = 1,
    @SerializedName("question_set")
    val questionSet: ArrayList<FlatPracticeQuestionSetSubmitted> = arrayListOf(),
)

data class FlatPracticeQuestionSetSubmitted(
    @SerializedName("question_id")
    val questionId: String,
    @SerializedName("question")
    val question: String,
    var answerSet: ArrayList<FlatPracticeAnswerSetSubmitted> = arrayListOf(),
)

data class FlatPracticeAnswerSetSubmitted(
    @SerializedName("answer_id")
    val answerId: String,
    @SerializedName("answer")
    val answer: String,
    @SerializedName("is_ture")
    val isTure: Boolean = false,
)

//----- File: flatpractice/data/repository/FlatPracticeRepositoryImpl.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.data.repository

import com.rzrasel.wordquiz.feature.flatpractice.data.datasource.FlatPracticeRemoteDataSource
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeDto
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeRequest
import com.rzrasel.wordquiz.feature.flatpractice.domain.repository.FlatPracticeRepository
import com.rzrasel.wordquiz.networkstate.NetworkState

class FlatPracticeRepositoryImpl(private val remoteDataSource: FlatPracticeRemoteDataSource):
    FlatPracticeRepository {
    override suspend fun getFlatPractice(flatPracticeRequest: FlatPracticeRequest): NetworkState<FlatPracticeDto> {
        return remoteDataSource.getFlatPractice(flatPracticeRequest)
    }

    override suspend fun getFlatPracticeNext(flatPracticeRequest: FlatPracticeRequest): NetworkState<FlatPracticeDto> {
        return remoteDataSource.getFlatPracticeNext(flatPracticeRequest)
    }
}

//----- File: flatpractice/di/FlatPracticeModule.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.di

import android.content.Context
import com.rzrasel.wordquiz.feature.flatpractice.data.repository.FlatPracticeRepositoryImpl
import com.rzrasel.wordquiz.feature.flatpractice.api.FlatPracticeApiService
import com.rzrasel.wordquiz.feature.flatpractice.data.datasource.FlatPracticeRemoteDataSource
import com.rzrasel.wordquiz.feature.flatpractice.data.datasource.FlatPracticeRemoteDataSourceImpl
import com.rzrasel.wordquiz.feature.flatpractice.domain.repository.FlatPracticeRepository
import com.rzrasel.wordquiz.feature.flatpractice.domain.usecase.FlatPracticeUseCase
import com.rzrasel.wordquiz.feature.flatpractice.presentation.viewmodel.FlatPracticeViewModel
import com.rzrasel.wordquiz.network.NetConnectionInterceptor
import com.rzrasel.wordquiz.network.RetrofitClient

object FlatPracticeModule {
    private fun provideApiService(context: Context, userAuthToken: String = ""): FlatPracticeApiService {
        val netConnInterceptor = NetConnectionInterceptor(context)
        return RetrofitClient().buildApi(
            context = context,
            api = FlatPracticeApiService::class.java,
            netConnectionInterceptor = netConnInterceptor,
            authToken = userAuthToken
        )
    }

    private fun provideRemoteDataSource(apiService: FlatPracticeApiService): FlatPracticeRemoteDataSource {
        return FlatPracticeRemoteDataSourceImpl(apiService)
    }

    private fun provideRepository(remoteDataSource: FlatPracticeRemoteDataSource): FlatPracticeRepository {
        return FlatPracticeRepositoryImpl(remoteDataSource)
    }

    private fun provideUseCase(repository: FlatPracticeRepository): FlatPracticeUseCase {
        return FlatPracticeUseCase(repository)
    }

    fun provideViewModel(context: Context, userAuthToken: String = ""): FlatPracticeViewModel {
        val apiService = provideApiService(context, userAuthToken)
        val remoteDataSource = provideRemoteDataSource(apiService)
        val repository = provideRepository(remoteDataSource)
        val useCase = provideUseCase(repository)
        //return FlatPracticeViewModel(useCase)
        return FlatPracticeViewModel(useCase)
    }
}

//----- File: flatpractice/domain/mapper/FlatPracticeDtoMapper.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.domain.mapper

import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeAnswerItemDto
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeDataDto
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeDto
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeQuestionItemDto
import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeAnswerItemModel
import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeDataModel
import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeModel
import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeQuestionItemModel

//Mapper (Model â†’ DTO) (Model To DTO)

fun FlatPracticeModel.toDto(): FlatPracticeDto {
    return FlatPracticeDto(
        type = type,
        message = message,
        data = data?.toDto()
    )
}

fun FlatPracticeDataModel.toDto(): FlatPracticeDataDto {
    return FlatPracticeDataDto(
        nextQuestionIndex = nextQuestionIndex,
        isLastQuestion = isLastQuestion,
        questionSet = ArrayList(questionSet?.map { it.toDto() } ?: emptyList())
    )
}

fun FlatPracticeQuestionItemModel.toDto(): FlatPracticeQuestionItemDto {
    return FlatPracticeQuestionItemDto(
        questionId = questionId,
        question = question,
        answerSet = answerSet.map { it.toDto() }
    )
}

fun FlatPracticeAnswerItemModel.toDto(): FlatPracticeAnswerItemDto {
    return FlatPracticeAnswerItemDto(
        answerId = answerId,
        answer = answer,
        isTure = isTure
    )
}

//----- File: flatpractice/domain/model/FlatPracticeModel.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.domain.model

import com.google.gson.annotations.SerializedName

data class FlatPracticeModel(
    @SerializedName("type")
    val type: String = "error",
    @SerializedName("message")
    val message: String? = null,
    @SerializedName("data")
    var data: FlatPracticeDataModel? = FlatPracticeDataModel(),
)

data class FlatPracticeDataModel(
    @SerializedName("next_question_index")
    var nextQuestionIndex: Int = 0,
    @SerializedName("is_last_question")
    var isLastQuestion: Boolean? = null,
    @SerializedName("question")
    var questionSet: ArrayList<FlatPracticeQuestionItemModel>? = arrayListOf(),
)

data class FlatPracticeQuestionItemModel(
    @SerializedName("question_id")
    val questionId: String? = null,
    @SerializedName("question")
    val question: String? = null,
    @SerializedName("answer_set")
    var answerSet: List<FlatPracticeAnswerItemModel> = listOf(),
)

data class FlatPracticeAnswerItemModel(
    @SerializedName("answer_id")
    val answerId: String? = null,
    @SerializedName("answer")
    val answer: String? = null,
    @SerializedName("is_true")
    val isTure: Boolean = false,
    var isSelected: Boolean = false,
)

//----- File: flatpractice/domain/model/FlatPracticeSubmitModel.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.domain.model

import com.google.gson.annotations.SerializedName
import com.rz.logwriter.DebugLog
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeRequest

class FlatPracticeSubmitModel(
    @SerializedName("user_auth_token")
    var userAuthToken: String = "",
    @SerializedName("is_login")
    var isLogin: Boolean = false,
    @SerializedName("category_id")
    var categoryId: String = "",
    @SerializedName("item_id")
    var itemId: String = "",
    @SerializedName("current_question_index")
    var currentQuestionIndex: Int = 1,
    @SerializedName("start_fresh")
    var startFresh: Boolean = false,
    @SerializedName("answers")
    var questionSet: ArrayList<FlatPracticeSubmitQuestionItemModel> = arrayListOf()
) {
    companion object {
        fun mapToSubmitModel(flatPracticeRequest: FlatPracticeRequest): FlatPracticeSubmitModel {
            //return FlatPracticeSubmitModel()
            val flatPracticeSubmitModel: FlatPracticeSubmitModel = FlatPracticeSubmitModel()
            flatPracticeSubmitModel.apply {
                userAuthToken = flatPracticeRequest.userAuthToken ?: ""
                isLogin = flatPracticeRequest.isLogin
                categoryId = flatPracticeRequest.categoryId
                itemId = flatPracticeRequest.itemId
                currentQuestionIndex = flatPracticeRequest.currentQuestionIndex
                startFresh = false
            }
            //
            val questionArrayList: ArrayList<FlatPracticeSubmitQuestionItemModel> = arrayListOf()
            //
            flatPracticeRequest.questionSet.forEach { question ->
                //DebugLog.Log("${question.questionId} question")
                val submitQuestionItemModel = FlatPracticeSubmitQuestionItemModel()
                submitQuestionItemModel.questionId = question.questionId
                val answerSet: ArrayList<String> = arrayListOf()
                question.answerSet.forEach { answer ->
                    //DebugLog.Log(answer.answerId)
                    if (answer.isTure) {
                        //DebugLog.Log("${answer.answerId} is selected")
                        answerSet.add(answer.answerId)
                    }
                }
                submitQuestionItemModel.answerSet = answerSet
                questionArrayList.add(submitQuestionItemModel)
                //flatPracticeSubmitModel.questionSet = submitQuestionItemModel
            }
            flatPracticeSubmitModel.questionSet = questionArrayList
            //
            return flatPracticeSubmitModel
        }
    }
}

class FlatPracticeSubmitQuestionItemModel(
    @SerializedName("question_id")
    var questionId: String = "",
    @SerializedName("selected_option_ids")
    var answerSet: ArrayList<String> = arrayListOf()
)

class FlatPracticeSubmitAnswerItemModel(
    @SerializedName("question_id")
    var questionId: Int? = null,
    @SerializedName("selected_option_ids")
    var selectedOptionIds: ArrayList<String> = arrayListOf()
)

//----- File: flatpractice/domain/repository/FlatPracticeRepository.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.domain.repository

import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeRequest
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeDto
import com.rzrasel.wordquiz.networkstate.NetworkState

interface FlatPracticeRepository {
    suspend fun getFlatPractice(flatPracticeRequest: FlatPracticeRequest): NetworkState<FlatPracticeDto>
    suspend fun getFlatPracticeNext(flatPracticeRequest: FlatPracticeRequest): NetworkState<FlatPracticeDto>
}

//----- File: flatpractice/domain/usecase/FlatPracticeUseCase.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.domain.usecase

import com.rz.logwriter.LogWriter
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeRequest
import com.rzrasel.wordquiz.feature.flatpractice.data.mapper.toModel
import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeModel
import com.rzrasel.wordquiz.feature.flatpractice.domain.repository.FlatPracticeRepository
import com.rzrasel.wordquiz.networkstate.NetworkState

class FlatPracticeUseCase(private val repository: FlatPracticeRepository) {
    suspend fun execute(
        userAuthToken: String?,
        categoryId: String,
        itemId: String,
        nextQuestionIndex: Int = 1
    ): NetworkState<FlatPracticeModel> {
        val userAuthTokenVal = userAuthToken ?: ""
        LogWriter.Log("User auth token: $userAuthTokenVal")
        val request = FlatPracticeRequest(
            userAuthToken = userAuthTokenVal.trim(),
            categoryId = categoryId,
            itemId = itemId,
            currentQuestionIndex = nextQuestionIndex
        )
        return when(val result = repository.getFlatPractice(request)) {
            is NetworkState.Success -> NetworkState.Success(result.data?.toModel())
            is NetworkState.Error -> NetworkState.Error(result.message)
            is NetworkState.Loading -> NetworkState.Loading(null)
        }
    }

    suspend fun executeNext(request: FlatPracticeRequest): NetworkState<FlatPracticeModel> {
        return when(val result = repository.getFlatPracticeNext(request)) {
            is NetworkState.Success -> NetworkState.Success(result.data?.toModel())
            is NetworkState.Error -> NetworkState.Error(result.message)
            is NetworkState.Loading -> NetworkState.Loading(null)
        }
    }
}

//----- File: flatpractice/presentation/components/composables/FlatPracticeButtonView.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.presentation.components.composables

import android.content.Context
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.size
import androidx.compose.runtime.Composable
import androidx.compose.runtime.MutableState
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.core.graphics.toColorInt
import com.rzrasel.wordquiz.presentation.components.components.ButtonComposable

@Composable
fun FlatPracticeButtonView(
    currentIndex: MutableState<Int>,
    totalQuestion: Int,
    isSingleQuestionView: Boolean = true,
    onClickSubmit: (Int)-> Unit,
) {
    val context: Context = LocalContext.current
    if(isSingleQuestionView) {
        FlatPracticeSingleQuestionViewButtons(
            currentIndex = currentIndex,
            totalQuestion = totalQuestion,
            onClickSubmit = onClickSubmit,
        )
    } else {
        Row(
            modifier = Modifier
                .fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Spacer(modifier = Modifier.size(10.dp))
            ButtonComposable(
                backgroundColor = Color("#239cbc".toColorInt()),
                contentColor = Color("#e9fcff".toColorInt()),
                fontWeight = FontWeight.Bold,
                cornerRadius = 6.dp,
                text = "Submit",
                onClick = {
                    //Toast.makeText(context, "Go for Submit", Toast.LENGTH_LONG).show()
                    onClickSubmit(totalQuestion - 1)
                }
            )
        }
    }
}

//----- File: flatpractice/presentation/components/composables/FlatPracticeQuestionView.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.presentation.components.composables

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.mutableStateListOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.core.graphics.toColorInt
import androidx.lifecycle.viewmodel.compose.viewModel
import com.rzrasel.wordquiz.presentation.components.components.RoundedCornerChip
import com.rzrasel.wordquiz.feature.flatpractice.presentation.viewmodel.FlatPracticeViewModel
import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeQuestionItemModel
import com.rzrasel.wordquiz.presentation.components.components.CustomCheckBox

@Composable
fun FlatPracticeQuestionView(questionIndex: Int, question: FlatPracticeQuestionItemModel, viewModel: FlatPracticeViewModel = viewModel()) {
    /*var isChecked by remember { mutableStateOf(false) }
    //val isCheckedList: List<Boolean> = listOf(false, false, false, false)
    val isCheckedList: List<Boolean> = listOf()
    question.answerSet.forEach {
        isCheckedList.add(false)
    }
    //var mutableStateOfCheckedList by remember { mutableStateOf(isCheckedList) }
    //val mutableStateOfCheckedList = remember { mutableStateListOf(isCheckedList) }
    val mutableStateOfCheckedList = remember { mutableStateListOf(*isCheckedList.toTypedArray()) }*/
    //
    val mutableStateOfCheckedList = remember { mutableStateListOf<Boolean>() }
    repeat(question.answerSet.size) {
        mutableStateOfCheckedList.add(false)
    }
    //val mutableStateOfCheckedList = MutableStateFlow<FlatPracticeQuestionSetModel>(question)
    //val mcqState by viewModel.mcqQuestionState.collectAsState()
    //
    Text(
        text = question.question!!,
        fontWeight = FontWeight.Bold,
    )
    Spacer(Modifier.height(16.dp))
    RoundedCornerChip(
        modifier = Modifier
            .fillMaxWidth()
            .background(Color("#f3f3f8".toColorInt()))
            .padding(0.dp),
        contentModifier = Modifier
            .fillMaxWidth()
            .background(Color("#f3f3f8".toColorInt()))
            .padding(8.dp),
        cornerRadius = 6,
        //backgroundColor = Color.Blue,
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth(),
        ) {
            /*question.answerSet.forEachIndexed { index, item ->
                CustomCheckBox(
                    modifier = Modifier
                        .fillMaxWidth(),
                    text = item.answer,
                    textColor = Color("#232323".toColorInt()),
                    checkedColor = Color("#ff239cbc".toColorInt()),
                    borderCheckedColor = Color("#ff239cbc".toColorInt()),
                    borderUncheckedColor = Color("#ffde7b73".toColorInt()),
                    isChecked = mutableStateOfCheckedList[index],
                    onCheckedChange = {
                        mutableStateOfCheckedList[index] = it
                    },
                )
            }*/
            question.answerSet.forEachIndexed { index, option ->
                mutableStateOfCheckedList[index] = option.isSelected
                CustomCheckBox(
                    modifier = Modifier
                        .fillMaxWidth(),
                    text = option.answer ?: "",
                    textColor = Color("#232323".toColorInt()),
                    checkedColor = Color("#ff239cbc".toColorInt()),
                    borderCheckedColor = Color("#ff239cbc".toColorInt()),
                    borderUncheckedColor = Color("#ffde7b73".toColorInt()),
                    //isChecked = option.isSelected,
                    isChecked = mutableStateOfCheckedList[index],
                    onCheckedChange = {
                        //option.isSelected = it
                        mutableStateOfCheckedList[index] = it
                        //Log.i("DEBUG_LOG", "onCheckedChange 1 ${question.toString()}")
                        viewModel.toggleOption(questionIndex, index)
                        //Log.i("DEBUG_LOG", "onCheckedChange 2 ${question.toString()}")
                    },
                )
            }
        }
    }
}

//----- File: flatpractice/presentation/components/composables/FlatPracticeSingleQuestionViewButtons.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.presentation.components.composables

import android.content.Context
import android.widget.Toast
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.size
import androidx.compose.runtime.Composable
import androidx.compose.runtime.MutableState
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.core.graphics.toColorInt
import com.rzrasel.wordquiz.presentation.components.components.ButtonComposable

@Composable
fun FlatPracticeSingleQuestionViewButtons(
    currentIndex: MutableState<Int>,
    totalQuestion: Int,
    onClickSubmit: (Int)-> Unit,
) {
    val context: Context = LocalContext.current
    Row(
        modifier = Modifier
            .fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        if(currentIndex.value > 0) {
            ButtonComposable(
                backgroundColor = Color("#de7b73".toColorInt()),
                contentColor = Color("#ffffff".toColorInt()),
                fontWeight = FontWeight.Bold,
                cornerRadius = 6.dp,
                text = "Previous",
                onClick = {
                    val previousIndex = currentIndex.value - 1
                    if (previousIndex < 0) {
                        Toast.makeText(context, "Go for previous", Toast.LENGTH_LONG).show()
                    } else {
                        currentIndex.value = previousIndex
                    }
                }
            )
        } else {
            Spacer(modifier = Modifier.size(10.dp))
        }
        if(currentIndex.value < totalQuestion - 1) {
            ButtonComposable(
                backgroundColor = Color("#239cbc".toColorInt()),
                contentColor = Color("#e9fcff".toColorInt()),
                fontWeight = FontWeight.Bold,
                cornerRadius = 6.dp,
                text = "Next",
                onClick = {
                    val nextIndex = currentIndex.value + 1
                    if (nextIndex >= totalQuestion) {
                        Toast.makeText(context, "Go for next", Toast.LENGTH_LONG).show()
                    } else {
                        currentIndex.value = nextIndex
                    }
                    //Toast.makeText(context, "Coming soon $nextIndex - ${flatReadingModel.questionSet.size}", Toast.LENGTH_LONG).show()
                }
            )
        } else {
            ButtonComposable(
                backgroundColor = Color("#239cbc".toColorInt()),
                contentColor = Color("#e9fcff".toColorInt()),
                fontWeight = FontWeight.Bold,
                cornerRadius = 6.dp,
                text = "Submit",
                onClick = {
                    /*val nextIndex = currentIndex.value + 1
                    if (nextIndex >= totalQuestion) {
                        Toast.makeText(context, "Go for submit", Toast.LENGTH_LONG).show()
                    } else {
                        currentIndex.value = nextIndex
                    }*/
                    //Toast.makeText(context, "Coming soon $nextIndex - ${flatReadingModel.questionSet.size}", Toast.LENGTH_LONG).show()
                    onClickSubmit(currentIndex.value)
                }
            )
        }
    }
}

//----- File: flatpractice/presentation/screen/AppFlatPracticeScreen.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.presentation.screen

import android.app.Application
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.platform.LocalContext
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.rz.logwriter.DebugLog
import com.rzrasel.wordquiz.feature.flatpractice.di.FlatPracticeModule
import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeSubmitModel
import com.rzrasel.wordquiz.feature.flatpractice.presentation.state.FlatPracticeUiState
import com.rzrasel.wordquiz.navigation.NavigationRouteHelper
import com.rzrasel.wordquiz.presentation.components.dialog.LoadingDialog
import com.rzrasel.wordquiz.presentation.screens.data.UserTaskItemModel

@Composable
fun AppFlatPracticeScreen(
    application: Application,
    userTaskItem: UserTaskItemModel = UserTaskItemModel(
        userAuthToken = "",
        categoryId = "",
        itemId = ""
    ),
    onClickBackButton: () -> Unit,
    onNavigateSubmitScreen: (FlatPracticeSubmitModel) -> Unit,
) {
    val context = LocalContext.current
    val viewModel = remember {
        FlatPracticeModule.provideViewModel(context, userTaskItem.userAuthToken)
    }
    val uiState by viewModel.uiState.collectAsState()
    var showLoadingDialog by remember { mutableStateOf(false) }

    when (uiState) {
        is FlatPracticeUiState.Idle -> {
            viewModel.getFlatPracticeInitial(
                userAuthToken = userTaskItem.userAuthToken,
                categoryId = userTaskItem.categoryId,
                itemId = userTaskItem.itemId,
            )
        }
        is FlatPracticeUiState.SubmitToScreen -> {
            val submitModel = (uiState as FlatPracticeUiState.SubmitToScreen).submitModel
            DebugLog.Log("Submit state")
            NavigationRouteHelper(
                shouldNavigate = { true },
                destination = { onNavigateSubmitScreen(submitModel) }
            )
        }
        is FlatPracticeUiState.Success -> {
            showLoadingDialog = false
            val flatPracticeModel = (uiState as FlatPracticeUiState.Success).flatPracticeModel
            DebugLog.Log(flatPracticeModel.toString())
            FlatPracticeScreen(
                application = application,
                viewModel = viewModel,
                userTaskItem = userTaskItem,
                flatPracticeModel = flatPracticeModel,
                onClickBackButton = onClickBackButton,
            )
        }
        else -> {
            showLoadingDialog = when (uiState) {
                is FlatPracticeUiState.Loading -> true
                else -> false
            }
            when (uiState) {
                is FlatPracticeUiState.Error -> {
                    val message = (uiState as FlatPracticeUiState.Error).message
                    DebugLog.Log(message)
                    FlatPracticeErrorScreen(
                        application = application,
                        viewModel = viewModel,
                        userTaskItem = userTaskItem,
                        onClickBackButton = onClickBackButton,
                    )
                } else -> {}
            }
        }
    }

    if (showLoadingDialog) {
        LoadingDialog("Please wait...") {
            showLoadingDialog = !showLoadingDialog
        }
    }
}

//----- File: flatpractice/presentation/screen/FlatPracticeErrorScreen.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.presentation.screen

import android.app.Application
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.google.accompanist.swiperefresh.SwipeRefresh
import com.google.accompanist.swiperefresh.rememberSwipeRefreshState
import com.rzrasel.wordquiz.core.utils.BuildInfo
import com.rzrasel.wordquiz.feature.flatpractice.presentation.state.FlatPracticeUiState
import com.rzrasel.wordquiz.feature.flatpractice.presentation.viewmodel.FlatPracticeViewModel
import com.rzrasel.wordquiz.presentation.components.components.AppTopAppBar
import com.rzrasel.wordquiz.presentation.components.layout.DefaultScaffold
import com.rzrasel.wordquiz.presentation.screens.data.UserTaskItemModel
import com.rzrasel.wordquiz.ui.theme.AppTheme

@Composable
fun FlatPracticeErrorScreen(
    application: Application,
    viewModel: FlatPracticeViewModel,
    userTaskItem: UserTaskItemModel = UserTaskItemModel(
        userAuthToken = "",
        categoryId = "",
        itemId = ""
    ),
    onClickBackButton: () -> Unit,
) {
    val context = LocalContext.current
    val isRefreshing by viewModel.isRefreshing.collectAsStateWithLifecycle()
    val swipeRefreshState = rememberSwipeRefreshState(isRefreshing = isRefreshing)
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()

    LaunchedEffect(swipeRefreshState.isRefreshing) {
        if (swipeRefreshState.isRefreshing) {
            viewModel.refreshFlatPractice(userTaskItem)
        }
    }

    DefaultScaffold(
        topBar = {
            AppTopAppBar(
                title = "Practice and Memorize",
                onClick = { onClickBackButton() }
            )
        }
    ) {
        SwipeRefresh(
            state = swipeRefreshState,
            onRefresh = { viewModel.refreshFlatPractice(userTaskItem) },
            modifier = Modifier.fillMaxSize()
        ) {
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .verticalScroll(rememberScrollState())
                    .padding(horizontal = AppTheme.dimens.paddingLarge)
                    .padding(bottom = AppTheme.dimens.paddingExtraLarge)
            ) {
                when (uiState) {
                    is FlatPracticeUiState.Error -> {
                        if (BuildInfo.isDebugging(context)) {
                            Text(
                                text = (uiState as FlatPracticeUiState.Error).message,
                                fontSize = 16.sp,
                                textAlign = TextAlign.Center,
                                modifier = Modifier.padding(16.dp)
                            )
                        }
                        Text(
                            text = "â¬‡\uFE0F Swipe down to refresh",
                            fontSize = 20.sp,
                            textAlign = TextAlign.Center,
                            modifier = Modifier.padding(16.dp)
                        )
                    }
                    else -> {
                        // Handle other states if needed
                    }
                }
            }
        }
    }
}

//----- File: flatpractice/presentation/screen/FlatPracticeScreen.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.presentation.screen

import android.app.Application
import android.content.Context
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import com.rzrasel.wordquiz.core.enumtype.RemoteResponseType
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeAnswerSetSubmitted
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeQuestionSetSubmitted
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeRequest
import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeModel
import com.rzrasel.wordquiz.feature.flatpractice.presentation.components.composables.FlatPracticeButtonView
import com.rzrasel.wordquiz.feature.flatpractice.presentation.components.composables.FlatPracticeQuestionView
import com.rzrasel.wordquiz.feature.flatpractice.presentation.state.FlatPracticeUiEvent
import com.rzrasel.wordquiz.feature.flatpractice.presentation.viewmodel.FlatPracticeViewModel
import com.rzrasel.wordquiz.presentation.components.components.AppTopAppBar
import com.rzrasel.wordquiz.presentation.components.layout.DefaultScaffold
import com.rzrasel.wordquiz.presentation.screens.data.UserTaskItemModel
import com.rzrasel.wordquiz.ui.theme.AppTheme

@Composable
fun FlatPracticeScreen(
    application: Application,
    viewModel: FlatPracticeViewModel,
    flatPracticeModel: FlatPracticeModel,
    userTaskItem: UserTaskItemModel = UserTaskItemModel(
        userAuthToken = "",
        categoryId = "",
        itemId = ""
    ),
    onClickBackButton: () -> Unit,
) {
    val context: Context = LocalContext.current
    val remQuestionIndex: MutableState<Int> = remember { mutableIntStateOf(0) }
    val mcqQuestionState by viewModel.mcqQuestionState.collectAsState()

    DefaultScaffold(
        topBar = {
            AppTopAppBar(
                title = "Practice and Memorize",
                onClick = { onClickBackButton() }
            )
        }
    ) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(top = 64.dp)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .verticalScroll(rememberScrollState())
                    .padding(horizontal = AppTheme.dimens.paddingLarge)
                    .padding(bottom = AppTheme.dimens.paddingExtraLarge)
            ) {
                val responseTypeValue: String = mcqQuestionState.type
                val responseType: RemoteResponseType = RemoteResponseType.find(responseTypeValue)

                when (responseType) {
                    RemoteResponseType.ERROR -> {
                        Text(text = "Error loading questions")
                    }
                    else -> {
                        val questionSet = mcqQuestionState.data?.questionSet ?: emptyList()
                        if (questionSet.isEmpty()) {
                            Text(text = "No questions available")
                        } else {
                            val currentIndex = remQuestionIndex.value.coerceIn(0, questionSet.size - 1)
                            questionSet.getOrNull(currentIndex)?.let { questionItem ->
                                FlatPracticeQuestionView(currentIndex, questionItem, viewModel)
                                Spacer(Modifier.height(16.dp))

                                FlatPracticeButtonView(
                                    currentIndex = remQuestionIndex,
                                    totalQuestion = questionSet.size,
                                    isSingleQuestionView = true,
                                    onClickSubmit = { index ->
                                        val submittedQuestions = arrayListOf<FlatPracticeQuestionSetSubmitted>()
                                        questionSet.forEach { question ->
                                            val answers = arrayListOf<FlatPracticeAnswerSetSubmitted>()
                                            question.answerSet.forEach { item ->
                                                answers.add(
                                                    FlatPracticeAnswerSetSubmitted(
                                                        answerId = item.answerId ?: "",
                                                        answer = item.answer ?: "",
                                                        isTure = item.isSelected,
                                                    )
                                                )
                                            }
                                            submittedQuestions.add(
                                                FlatPracticeQuestionSetSubmitted(
                                                    questionId = question.questionId ?: "",
                                                    question = question.question ?: "",
                                                    answerSet = answers,
                                                )
                                            )
                                        }
                                        val nextQuestionIndex = flatPracticeModel.data?.nextQuestionIndex ?: 1
                                        userTaskItem.currentQuestionIndex = nextQuestionIndex
                                        val request = FlatPracticeRequest(
                                            userAuthToken = userTaskItem.userAuthToken,
                                            categoryId = userTaskItem.categoryId,
                                            itemId = userTaskItem.itemId,
                                            currentQuestionIndex = nextQuestionIndex,
                                            questionSet = submittedQuestions,
                                        )
                                        viewModel.onUiEvent(FlatPracticeUiEvent.Submit(request))
                                    }
                                )
                            }
                        }
                    }
                }
            }
        }
    }
}


//----- File: flatpractice/presentation/state/FlatPracticeUiEvent.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.presentation.state

import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeRequest

sealed class FlatPracticeUiEvent {
    data object SubmitPrevious: FlatPracticeUiEvent()
    data object SubmitNext: FlatPracticeUiEvent()
    data class Submit(val flatPracticeRequest: FlatPracticeRequest): FlatPracticeUiEvent()
}

//----- File: flatpractice/presentation/state/FlatPracticeUiState.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.presentation.state

import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeModel
import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeSubmitModel

sealed class FlatPracticeUiState {
    data object Idle: FlatPracticeUiState()
    data object Loading: FlatPracticeUiState()
    data object Submit: FlatPracticeUiState()
    data class SubmitToScreen(val submitModel: FlatPracticeSubmitModel): FlatPracticeUiState()
    data class Success(val flatPracticeModel: FlatPracticeModel) : FlatPracticeUiState()
    data class Error(val message: String): FlatPracticeUiState()
    data class Result(val message: String): FlatPracticeUiState()
}

//----- File: flatpractice/presentation/viewmodel/FlatPracticeViewModel.kt -----

package com.rzrasel.wordquiz.feature.flatpractice.presentation.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.rz.logwriter.DebugLog
import com.rzrasel.wordquiz.core.enumtype.RemoteResponseType
import com.rzrasel.wordquiz.feature.flatpractice.data.remote.FlatPracticeRequest
import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeAnswerItemModel
import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeModel
import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeQuestionItemModel
import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeSubmitModel
import com.rzrasel.wordquiz.feature.flatpractice.domain.usecase.FlatPracticeUseCase
import com.rzrasel.wordquiz.feature.flatpractice.presentation.state.FlatPracticeUiEvent
import com.rzrasel.wordquiz.feature.flatpractice.presentation.state.FlatPracticeUiState
import com.rzrasel.wordquiz.networkstate.NetworkState
import com.rzrasel.wordquiz.presentation.screens.data.UserTaskItemModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

class FlatPracticeViewModel(
    private val flatPracticeUseCase: FlatPracticeUseCase
) : ViewModel() {
    private val _uiState = MutableStateFlow<FlatPracticeUiState>(FlatPracticeUiState.Idle)
    val uiState: StateFlow<FlatPracticeUiState> = _uiState

    private val _mcqQuestionState = MutableStateFlow<FlatPracticeModel>(
        FlatPracticeModel(
            type = RemoteResponseType.ERROR.name.lowercase(),
            message = "Initializing...",
            data = null
        )
    )
    val mcqQuestionState: StateFlow<FlatPracticeModel> = _mcqQuestionState

    private val _mcqSubmitQuestionSet = MutableStateFlow<FlatPracticeSubmitModel>(FlatPracticeSubmitModel())
    val mcqSubmitQuestionSet: StateFlow<FlatPracticeSubmitModel> = _mcqSubmitQuestionSet

    private val _isRefreshing = MutableStateFlow(false)
    val isRefreshing: StateFlow<Boolean> = _isRefreshing.asStateFlow()

    fun getFlatPracticeInitial(userAuthToken: String?, categoryId: String, itemId: String, nextQuestionId: Int = 1) {
        viewModelScope.launch(Dispatchers.IO) {
            _uiState.value = FlatPracticeUiState.Loading
            try {
                when (val result = flatPracticeUseCase.execute(userAuthToken, categoryId, itemId, nextQuestionId)) {
                    is NetworkState.Success -> {
                        result.data?.let {
                            _mcqQuestionState.value = it.copy(
                                type = it.type.ifEmpty { RemoteResponseType.SUCCESS.name.lowercase() },
                                message = it.message ?: "Success"
                            )
                            _uiState.value = FlatPracticeUiState.Success(it)
                        } ?: run {
                            handleError("No data received")
                        }
                    }
                    is NetworkState.Error -> {
                        handleError(result.message ?: "Unknown error")
                    }
                    is NetworkState.Loading -> {
                        // Handle loading if needed
                    }
                }
            } catch (e: Exception) {
                handleError(e.message ?: "Network error")
            } finally {
                _isRefreshing.value = false
            }
        }
    }

    private fun handleError(message: String) {
        _mcqQuestionState.value = FlatPracticeModel(
            type = RemoteResponseType.ERROR.name.lowercase(),
            message = message
        )
        _uiState.value = FlatPracticeUiState.Error(message)
    }

    fun onUiEvent(event: FlatPracticeUiEvent) {
        when (event) {
            is FlatPracticeUiEvent.Submit -> {
                val flatPracticeRequest: FlatPracticeRequest = event.flatPracticeRequest
                /*flatPracticeRequest.questionSet.forEach { question ->
                    DebugLog.Log("${question.questionId} question")
                    question.answerSet.forEach { answer ->
                        //DebugLog.Log(answer.answerId)
                        if(answer.isTure) {
                            DebugLog.Log("${answer.answerId} is selected")
                        }
                    }
                }*/
                //
                getFlatPracticeNext(flatPracticeRequest)
            }
            else -> {
                // Handle other events
            }
        }
    }

    fun toggleOption(index: Int, optionIndex: Int) {
        val currentState = _mcqQuestionState.value
        val data = currentState.data ?: return
        val questionSet = data.questionSet ?: return
        if (index >= questionSet.size) return

        val question = questionSet[index]
        val answerSet = question.answerSet ?: return
        if (optionIndex >= answerSet.size) return

        val updatedOptions = answerSet.mapIndexed { point, option ->
            if (point == optionIndex) option.copy(isSelected = !option.isSelected) else option
        }

        val updatedQuestionSet = ArrayList(questionSet).apply {
            set(index, question.copy(answerSet = updatedOptions))
        }

        _mcqQuestionState.value = currentState.copy(
            data = data.copy(
                questionSet = updatedQuestionSet
            )
        )
    }

    private fun getFlatPracticeNext(request: FlatPracticeRequest, isNewWindow: Boolean = true) {
        if(isNewWindow) {
            val flatPracticeSubmitModel: FlatPracticeSubmitModel = FlatPracticeSubmitModel.mapToSubmitModel(request)
            DebugLog.Log(flatPracticeSubmitModel.toString())
            _mcqSubmitQuestionSet.value = flatPracticeSubmitModel
            _uiState.value = FlatPracticeUiState.SubmitToScreen(flatPracticeSubmitModel)
            return
        }
        viewModelScope.launch(Dispatchers.IO) {
            _uiState.value = FlatPracticeUiState.Loading
            when (val result = flatPracticeUseCase.executeNext(request)) {
                is NetworkState.Success -> {
                    result.data?.let {
                        _mcqQuestionState.value = it
                        _uiState.value = FlatPracticeUiState.Success(it)
                    } ?: run {
                        handleError("Null data")
                    }
                }
                is NetworkState.Error -> {
                    handleError(result.message ?: "Unknown error")
                }
                is NetworkState.Loading -> {
                    // Handle loading if needed
                }
            }
        }
    }

    fun refreshFlatPractice(userTaskItem: UserTaskItemModel) {
        _isRefreshing.value = true
        getFlatPracticeInitial(
            userAuthToken = userTaskItem.userAuthToken,
            categoryId = userTaskItem.categoryId,
            itemId = userTaskItem.itemId,
            nextQuestionId = userTaskItem.currentQuestionIndex
        )
    }

    fun submitPractice() {
        viewModelScope.launch {
            _uiState.value = FlatPracticeUiState.SubmitToScreen(_mcqSubmitQuestionSet.value)
        }
    }
}


//----- File: navigation/AppNavigation.kt -----

package com.rzrasel.wordquiz.navigation

import android.app.Application
import androidx.compose.runtime.Composable
import androidx.navigation.NavBackStackEntry
import androidx.navigation.NavHostController
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.toRoute
import com.rzrasel.wordquiz.core.enumtype.AccessMode
import com.rzrasel.wordquiz.core.enumtype.CategoryType
import com.rzrasel.wordquiz.feature.dashboard.presentation.screen.AppDashboardScreen
import com.rzrasel.wordquiz.feature.flatpractice.domain.model.FlatPracticeSubmitModel
import com.rzrasel.wordquiz.presentation.screens.data.UserModel
import com.rzrasel.wordquiz.presentation.screens.data.UserTaskItemModel
import com.rzrasel.wordquiz.feature.flatpractice.presentation.screen.AppFlatPracticeScreen
import com.rzrasel.wordquiz.feature.flatpracticesubmit.presentation.screen.AppFlatPracticeSubmitScreen
import com.rzrasel.wordquiz.presentation.screens.flatreading.AppFlatReadingScreen
import com.rzrasel.wordquiz.presentation.screens.login.AppLoginScreen
import com.rzrasel.wordquiz.presentation.screens.registration.AppRegistrationScreen
import com.rzrasel.wordquiz.presentation.screens.splash.SplashScreen

@Composable
fun AppNavigation(application: Application, navController: NavHostController) {
    //val navController = rememberNavController()
    var userModel: UserModel? = UserModel("")
    NavHost(navController = navController, startDestination =  NavigationRoute.SplashScreen) {
        composable<NavigationRoute.SplashScreen> {
            NavigateToSplashScreen(navController)
        }
        composable<NavigationRoute.LoginScreen> {
            NavigateToLoginScreen(application, navController)
        }
        composable<NavigationRoute.RegistrationScreen> {
            NavigateToRegistrationScreen(application, navController)
        }
        composable<NavigationRoute.DashboardScreen> { backStackEntry ->
            NavigateToDashboardScreen(application, navController, backStackEntry)
        }
        composable<NavigationRoute.FlatReadingScreen> { backStackEntry ->
            NavigateToFlatReadingScreen(application, navController, backStackEntry)
        }
        composable<NavigationRoute.FlatPracticeScreen> { backStackEntry ->
            NavigateToFlatPracticeScreen(application, navController, backStackEntry)
        }
        composable<NavigationRoute.FlatPracticeSubmitScreen> { backStackEntry ->
            NavigateToFlatPracticeSubmitScreen(application, navController, backStackEntry)
        }
        composable<NavigationRoute.TaskItemScreen> { backStackEntry ->
            NavigateToTaskItemScreen(application, navController, backStackEntry)
        }
    }
}

// SplashScreen Route
@Composable
fun NavigateToSplashScreen(navController: NavHostController) {
    return SplashScreen(
        onNavigateToLoginScreen = {
            navController.navigate(NavigationRoute.LoginScreen) {
                popUpTo(0)
            }
        }
    )
}

// LoginScreen Route
@Composable
fun NavigateToLoginScreen(application: Application, navController: NavHostController) {
    return AppLoginScreen(
        application = application,
        onNavigateToRegistrationScreen = {
            navController.navigate(NavigationRoute.RegistrationScreen) {
                popUpTo(0)
            }
        },
        onNavigateToDashboardScreen = { userModel ->
            val userAuthToken = userModel.userAuthToken ?: ""
            navController.navigate(NavigationRoute.DashboardScreen(userAuthToken)) {
                popUpTo(0)
            }
        }
    )
}

// RegistrationScreen Route
@Composable
fun NavigateToRegistrationScreen(application: Application, navController: NavHostController) {
    return AppRegistrationScreen(
        application = application,
        onNavigateToLoginScreen = {
            navController.navigate(NavigationRoute.LoginScreen) {
                popUpTo(0)
            }
        }
    )
}

// DashboardScreen Route
@Composable
fun NavigateToDashboardScreen(application: Application, navController: NavHostController, backStackEntry: NavBackStackEntry) {
    val userData = requireNotNull(backStackEntry.toRoute<NavigationRoute.DashboardScreen>())
    return AppDashboardScreen(
        application = application,
        userModel = UserModel(userAuthToken = userData.userAuthToken),
        onNavigateToFlatReading = { userTaskItem ->
            navController.navigate(
                NavigationRoute.FlatReadingScreen(
                    userAuthToken = userTaskItem.userAuthToken,
                    categoryId = userTaskItem.categoryId,
                    itemId = userTaskItem.itemId
                )
            )
        },
        onNavigateToTaskItem = { userTaskItem ->
            navController.navigate(
                NavigationRoute.TaskItemScreen(
                    userAuthToken = userTaskItem.userAuthToken,
                    categoryId = userTaskItem.categoryId,
                    categoryType = userTaskItem.categoryType,
                    itemId = userTaskItem.itemId,
                    accessMode = userTaskItem.accessMode
                )
            )
        }
    )
}

// FlatReadingScreen Route
@Composable
fun NavigateToFlatReadingScreen(application: Application, navController: NavHostController, backStackEntry: NavBackStackEntry) {
    val userTaskItem = requireNotNull(backStackEntry.toRoute<NavigationRoute.FlatReadingScreen>())
    return AppFlatReadingScreen(
            application = application,
            userTaskItem = UserTaskItemModel(
                userAuthToken = userTaskItem.userAuthToken,
                categoryId = userTaskItem.categoryId,
                itemId = userTaskItem.itemId
            ),
            onClickBackButton = {
                navController.popBackStack()
            }
        )
}

// FlatPracticeScreen Route
@Composable
fun NavigateToFlatPracticeScreen(application: Application, navController: NavHostController, backStackEntry: NavBackStackEntry) {
    val userTaskItem = requireNotNull(backStackEntry.toRoute<NavigationRoute.FlatPracticeScreen>())
    return AppFlatPracticeScreen(
        application = application,
        userTaskItem = UserTaskItemModel(
            userAuthToken = userTaskItem.userAuthToken,
            categoryId = userTaskItem.categoryId,
            itemId = userTaskItem.itemId
        ),
        onClickBackButton = {
            navController.popBackStack()
        },
        onNavigateSubmitScreen = { practiceSubmitModel ->
            navController.navigate(
                NavigationRoute.FlatPracticeSubmitScreen(
                    userAuthToken = practiceSubmitModel.userAuthToken,
                    categoryId = practiceSubmitModel.categoryId,
                    itemId = practiceSubmitModel.itemId,
                )
            )
        },
    )
}

@Composable
fun NavigateToFlatPracticeSubmitScreen(application: Application, navController: NavHostController, backStackEntry: NavBackStackEntry) {
    val practiceSubmitModel = requireNotNull(backStackEntry.toRoute<NavigationRoute.FlatPracticeSubmitScreen>())
    return AppFlatPracticeSubmitScreen(
        application = application,
        practiceSubmitModel = FlatPracticeSubmitModel(
        ),
        onClickBackButton = {
            navController.popBackStack()
        },
    )
}

// TaskItemScreen Route
@Composable
fun NavigateToTaskItemScreen(application: Application, navController: NavHostController, backStackEntry: NavBackStackEntry) {
    val userTaskItem = requireNotNull(backStackEntry.toRoute<NavigationRoute.TaskItemScreen>())
    return NavigateRouteToTaskItemScreen(
        application = application,
        navController = navController,
        userTaskItemModel = UserTaskItemModel(
            userAuthToken = userTaskItem.userAuthToken,
            categoryId = userTaskItem.categoryId,
            categoryType = userTaskItem.categoryType,
            itemId = userTaskItem.itemId,
            accessMode = userTaskItem.accessMode
        )
    )
}

@Composable
fun NavigateRouteToTaskItemScreen(
    application: Application,
    navController: NavHostController,
    userTaskItemModel: UserTaskItemModel,
) {
    val accessMode: AccessMode = AccessMode.find(userTaskItemModel.accessMode)
    val categoryType: CategoryType = CategoryType.find(userTaskItemModel.categoryType)
    //
    when(categoryType) {
        CategoryType.READING -> {
            AppFlatReadingScreen(
                application = application,
                userTaskItem = userTaskItemModel,
                onClickBackButton = {
                    //navController.navigateUp()
                    navController.popBackStack()
                },
            )
        } CategoryType.PRACTICE -> {
            AppFlatPracticeScreen(
                application = application,
                userTaskItem = userTaskItemModel,
                onClickBackButton = {
                    navController.navigateUp()
                },
                onNavigateSubmitScreen = {},
            )
        } else -> {}
    }
}

//----- File: navigation/NavigationRoute.kt -----

package com.rzrasel.wordquiz.navigation

import kotlinx.serialization.Serializable

object NavigationRoute {
    @Serializable
    object SplashScreen
    @Serializable
    object LoginScreen
    @Serializable
    object RegistrationScreen
    /*@Serializable
    object DashboardScreen*/
    @Serializable
    data class DashboardScreen(val userAuthToken: String)
    /*@Serializable
    data class DashboardScreen(val userModel: UserModel)*/
    @Serializable
    data class FlatReadingScreen(val userAuthToken: String, val categoryId: String, val itemId: String)
    @Serializable
    data class FlatPracticeScreen(val userAuthToken: String, val categoryId: String, val itemId: String)
    @Serializable
    data class FlatPracticeSubmitScreen(val userAuthToken: String, val categoryId: String, val itemId: String)
    @Serializable
    data class TaskItemScreen(val userAuthToken: String, val categoryId: String, val categoryType: String, val itemId: String, val accessMode: String)
    @Serializable
    data class DefeatWinScreen(val userAuthToken: String, val categoryId: String, val itemId: String, val lastQuestionId: String)
    @Serializable
    object PopBackStackUp
}

/*
https://pl-coding.com/2024/10/02/official-type-safe-navigation-with-compose/
https://github.com/philipplackner/ComposeNavigationCustomTypes
*/

@Serializable
sealed class Screens {
    @Serializable
    object Auth {
        @Serializable
        object EmailSignUp

        @Serializable
        object EmailLogIn
    }

    @Serializable
    object App {
        @Serializable
        data class Home(
            val name: String = "default",
        )
    }
}

//----- File: navigation/NavigationRouteHelper.kt -----

package com.rzrasel.wordquiz.navigation

import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect

@Composable
fun NavigationRouteHelper(
    shouldNavigate: ()-> Boolean,
    destination: ()-> Unit
) {
    LaunchedEffect(key1 = shouldNavigate()) {
        if(shouldNavigate()) {
            destination()
        }
    }
}







- give full directory structure first
- convert in mvvm clean architecture
- restructure refactor directory structure as mvvm clean architecture code
- use manual dependency injection

- FlatPracticeUiState is Submit navigate to AppFlatPracticeSubmitScreen screen
navigate to AppFlatPracticeSubmitScreen screen NavigateToFlatPracticeSubmitScreen using FlatPracticeSubmitModel data model with NavigationRoute FlatPracticeSubmitScreen
- how to convert FlatPracticeSubmitModel to NavigationRoute FlatPracticeSubmitScreen data
- FlatPracticeSubmitModel convert json string and pass in NavigationRoute FlatPracticeSubmitScreen

- use NetConnectionInterceptor, RetrofitClient, NetworkState for global project
- manual dependency injection di use FlatPracticeModule

*** manual dependency injection
*** provide import statements
*** code refactor if better options
*** Don't change class name if not needed
*** Don't change unwanted codebase
*** Provide Full Codebase
*** read full document properly